#### const和三目运算符

在C++中，由const修饰的变量，在未引用地址的情况下，会在编译阶段变成常量，没有空间
同时具有内部连接属性，外部连接属性需要加上extern
C++中，三目运算符返回的是左值，可改变的值

#### 类的封装

* 权限
public 公有权限
private 私有权限
protected 保护权限
* 访问与继承
公有权限，可以被任何类访问，包括子类和其他任何类
私有权限，只能在父类内部访问
保护权限，只能被子类及同一包中的类访问
子类继承父类的公有权限和保护权限
* 与结构体的区别
结构体默认成员为公有权限，类默认成员为私有权限

#### const

在函数前加上const就变成常函数 在对象前加上const变成常对象
常函数 常对象不能修改普通成员变量
常对象不可以调用普通成员函数 但可以调用常函数
特殊的 如果加上前缀mutable 则常函数常对象都可以改变

#### 友元函数

friend声明在原类的函数和类可以访问原类的私有成员变量 这是一种特权升级 并非另创建一个新类 
1. 友元关系不能被继承
2. 友元关系是单向的
3. 友元关系不具有传递性

#### 继承中的构造和析构

先调用父类的构造函数，在调用子类的构造函数，析构函数相反
当继承和父类混搭时，先调用父类的构造函数，再是成员的构造函数，最后是本身的构造函数，析构则相反
当子类和父类有同名成员时，子类的同名成员会隐藏父类的同名成员，但可以通过作用域来访问如子类.父类::同名变量,函数同理

#### 连编

+ 静态编译
调用类中的函数在编译阶段就确定了函数调用的地址
+ 动态编译
在普通成员函数前加virtual,变为虚函数，编译器就会晚绑定

#### 使用nullptr代替NULL

在c++语言中NULL==0，在一些函数重载中就会导致歧义，如

    void foo(char*);
    void foo(int);

在这里，如果传参NULL,编译器就会调用（int）函数，因为NULL被定义为整数类型0,而nullptr则是独立类型的nullptr_t，可以被正确区分

#### 常量和常量表达式

常量和常量表达式都涉及不可修改的值，但常量是可能在运行期间赋值并固定下来，也就是说在编译期间不能确定的值，如const声明的值，而常量表达式是在编译期间就能计算出结果的表达式，（注意是计算，可以是一个固定的值经过一个函数返回确定的值，并非一定是一个固定的数，如constexpr修饰的对象


#### 类型推导

C++引入了auto关键字，auto可以自动推导变量类型，在一些迭代器的使用上能大大简化代码
>auto还不能推导数组类型
C++还引入了decltype,他是为了解决auto关键字只能对变量进行类型推导的缺陷而出现的

    auto x=1;
    auto y=2;
    decltype(x+y) z;

